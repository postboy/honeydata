/*
common code for test programs for honeydata library
license: BSD 2-Clause
*/

#include "t_common.h"

//parameters in following generic functions:
//itype - type of input elements
//atype - type of auxiliary elements
//MIN - minimum value of current type
//FORMAT - format string for printf()
//MASK - bitmask for setting is_quiet bit of NaNs

//generic function for getting a number of occurences of different elements in integer array-------

#define STATS_INT_ARRAY(itype, MIN) \
(const itype *in_array, const size_t size, uint64_t *stats) \
{ \
	/*check the arguments*/ \
	if (in_array == NULL) { \
		error("in_array = NULL"); \
		return 1; \
		} \
	if (size == 0) { \
		error("size = 0"); \
		return 2; \
		} \
	if (stats == NULL) { \
		error("stats = NULL"); \
		return 3; \
		} \
	\
	itype elt;	/*current processing element*/ \
	size_t i; \
	\
	for (i = 0; i < size; i++) { \
		elt = in_array[i];	/*read the current element*/ \
		++stats[elt - MIN];	/*increment the corresponding number in output array*/ \
		} \
	\
	return 0; \
}

extern int8_t stats_uint8_array
	STATS_INT_ARRAY(uint8_t, 0)

extern int8_t stats_int8_array
	STATS_INT_ARRAY(int8_t, INT8_MIN)

extern int8_t stats_uint16_array
	STATS_INT_ARRAY(uint16_t, 0)

extern int8_t stats_int16_array
	STATS_INT_ARRAY(int16_t, INT16_MIN)

#undef STATS_INT_ARRAY

//generic function for printing a numeric array----------------------------------------------------

#define PRINT_ARRAY(itype, FORMAT) \
(const itype *array, const size_t size) \
{ \
	/*check the arguments*/ \
	if (array == NULL) { \
		error("array = NULL"); \
		return 1; \
		} \
	if (size == 0) { \
		error("size = 0"); \
		return 2; \
		} \
	\
	size_t i; \
	\
	for (i = 0; i < size; i++) \
		printf( (FORMAT), array[i]); \
	printf("\n"); \
	return 0; \
}

extern int8_t print_uint8_array
	PRINT_ARRAY(uint8_t, "%"PRIu8" ")

extern int8_t print_int8_array
	PRINT_ARRAY(int8_t, "%"PRIi8" ")

extern int8_t print_uint16_array
	PRINT_ARRAY(uint16_t, "%"PRIu16" ")

extern int8_t print_int16_array
	PRINT_ARRAY(int16_t, "%"PRIi16" ")

extern int8_t print_uint32_array
	PRINT_ARRAY(uint32_t, "%"PRIu32" ")

extern int8_t print_int32_array
	PRINT_ARRAY(int32_t, "%"PRIi32" ")

extern int8_t print_uint64_array
	PRINT_ARRAY(uint64_t, "%"PRIu64" ")

extern int8_t print_int64_array
	PRINT_ARRAY(int64_t, "%"PRIi64" ")

extern int8_t print_float_array
	PRINT_ARRAY(float, "%e ")

extern int8_t print_double_array
	PRINT_ARRAY(double, "%e ")

extern int8_t print_longd_array
	PRINT_ARRAY(long double, "%Le ")

#undef PRINT_ARRAY

//generic function for conversion from signaling NaNs to quiet NaNs--------------------------------

/*during testing, it was found that conversion from signaling NaN to integer and back gives quiet
NaN, so this functions were written for ease of testing. here we work with binary format, most
significand exponent bit determines does NaN is quiet (bit = 1) or signaling (bit = 0).

optimization note: turns out that just "for (i = 0; i < size; i++) out_array[i] = in_array[i]" may
be enough to convert all signaling NaNs to quiet NaNs, but it may be not portable.

quote https://en.wikipedia.org/wiki/NaN:
In practice, the most significant bit of the significand field determined whether a NaN is
signaling or quiet. Two different implementations, with reversed meanings, resulted:
- most processors (including those of the Intel and AMD's x86 family, the Motorola 68000 family,
the AIM PowerPC family, the ARM family, and the Sun SPARC family) set the signaling/quiet bit to
non-zero if the NaN is quiet, and to zero if the NaN is signaling. Thus, on these processors, the
bit represents an 'is_quiet' flag;
- in NaNs generated by the PA-RISC and MIPS processors, the signaling/quiet bit is zero if the NaN
is quiet, and non-zero if the NaN is signaling. Thus, on these processors, the bit represents an
'is_signaling' flag.

The 2008 revision of the IEEE 754 standard (IEEE 754-2008) makes formal recommendations for the
encoding of the signaling/quiet state.
- For binary formats, the most significant bit of the significand field should be an 'is_quiet'
flag. I.e. this bit is non-zero if the NaN is quiet, and zero if the NaN is signaling.
- For decimal formats, whether binary or decimal encoded, a NaN is identified by having the top
five bits of the combination field after the sign bit set to ones. The sixth bit of the field is
the 'is_quiet' flag. The standard follows the interpretation as an 'is_signaling' flag. I.e. the
signaling/quiet bit is zero if the NaN is quiet, and non-zero if the NaN is signaling. A signaling
NaN is quieted by clearing this sixth bit.*/

#define TO_QUIET_NANS(itype, atype, MASK) \
(const itype *in_array, itype *out_array, const size_t size) \
{ \
	/*check the arguments*/ \
	if (in_array == NULL) { \
		error("in_array = NULL"); \
		return 1; \
		} \
	if (out_array == NULL) { \
		error("out_array = NULL"); \
		return 2; \
		} \
	if (size == 0) { \
		error("size = 0"); \
		return 3; \
		} \
	\
	size_t i; \
	/*current processing element after conversion. we use union notation here for access to \
	bitwise operations.*/ \
	union { \
		itype fp; \
		atype i; \
		} ielt; \
	\
	for (i = 0; i < size; i++) \
		/*if current element is NaN then set is_quiet bit and copy it, else just copy it*/ \
		if (isnan(in_array[i])) { \
			ielt.fp = in_array[i]; \
			ielt.i = ielt.i | MASK; \
			out_array[i] = ielt.fp; \
			} \
		else \
			out_array[i] = in_array[i]; \
	\
	return 0; \
}

extern int8_t float_to_quiet_nans
	TO_QUIET_NANS(float, uint32_t, 0x00400000)

extern int8_t double_to_quiet_nans
	TO_QUIET_NANS(double, uint64_t, 0x0008000000000000)

#undef TO_QUIET_NANS

extern void test_init(void)
{
	//initialise the crypto library
	ERR_load_crypto_strings();
	OpenSSL_add_all_algorithms();
	//OPENSSL_config(NULL);
	if (!RAND_status()) {
		error("PRNG hasn't been seeded with enough data");
		exit(1);
		}
}

extern void test_deinit(void)
{
	//clean up
	RAND_cleanup();
	EVP_cleanup();
	ERR_free_strings();
}

extern void OpenSSL_error(void)
{
	ERR_print_errors_fp(stderr);
	test_error();
}

extern void test_error(void)
{
	test_deinit();
	exit(1);
}

//encrypt a message
extern int encrypt(const unsigned char *plaintext, const size_t plaintext_len,
	const unsigned char *key, const unsigned char *iv, unsigned char *ciphertext)
{
	EVP_CIPHER_CTX *ctx;
	int len, ciphertext_len;

	//create and initialise the context
	if (!(ctx = EVP_CIPHER_CTX_new()))
		OpenSSL_error();
	//EVP_CIPHER_CTX_set_padding(ctx, 0);
	
	/*Initialise the encryption operation. IMPORTANT - ensure you use a key and IV size
	appropriate for your cipher. In this example we are using 256 bit AES (i.e. a 256 bit key). The
	IV size for *most* modes is the same as the block size. For AES this is 128 bits.*/
	if (EVP_EncryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, key, iv) != 1)
		OpenSSL_error();
	EVP_CIPHER_CTX_set_padding(ctx, 0);
	/*We should disable the padding for plausible decryption with any decryption key. The total
	amount of data encrypted or decrypted must then be a multiple of the block size or an error
	will occur.*/

	/*Provide the message to be encrypted, and obtain the encrypted output. EVP_EncryptUpdate can
	be called multiple times if necessary.*/
	if (EVP_EncryptUpdate(ctx, ciphertext, &len, plaintext, plaintext_len) != 1)
		OpenSSL_error();
	ciphertext_len = len;

	//Finalise the encryption. Further ciphertext bytes may be written at this stage.
	if (EVP_EncryptFinal_ex(ctx, ciphertext + len, &len) != 1)
		OpenSSL_error();
	ciphertext_len += len;

	//clean up
	EVP_CIPHER_CTX_free(ctx);

	return ciphertext_len;
}

//decrypt a message
extern int decrypt(const unsigned char *ciphertext, const size_t ciphertext_len,
	const unsigned char *key, const unsigned char *iv, unsigned char *plaintext)
{
	EVP_CIPHER_CTX *ctx;
	int len, plaintext_len;
	
	//create and initialise the context
	if (!(ctx = EVP_CIPHER_CTX_new()))
		OpenSSL_error();
	
	/*Initialise the decryption operation. IMPORTANT - ensure you use a key and IV size appropriate
	for your cipher. In this example we are using 256 bit AES (i.e. a 256 bit key). The IV size for
	*most* modes is the same as the block size. For AES this is 128 bits.*/
	if (EVP_DecryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, key, iv) != 1)
		OpenSSL_error();
	EVP_CIPHER_CTX_set_padding(ctx, 0);	//disable padding
	
	/*Provide the message to be decrypted, and obtain the plaintext output. EVP_DecryptUpdate can
	be called multiple times if necessary.*/
	if (EVP_DecryptUpdate(ctx, plaintext, &len, ciphertext, ciphertext_len) != 1)
		OpenSSL_error();
	plaintext_len = len;
	
	//Finalise the decryption. Further plaintext bytes may be written at this stage.
	if (EVP_DecryptFinal_ex(ctx, plaintext + len, &len) != 1)
		OpenSSL_error();
	plaintext_len += len;
	
	//clean up
	EVP_CIPHER_CTX_free(ctx);
	
	return plaintext_len;
}
